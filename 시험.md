## chap 2 (보통 문제 1번)
### 데이터 구조 및 전처리
```
Train_images.shape
Len(train_labels)  -> 두개 길이 일치 찾는거
Train_labels -> 구조 확인
```

### 전처리
```
train_images.reshape((60000, 28*28)) -> 28*28의 크기가 되도록
train_images.astype("float")/255 -> 0 ~ 1 범위가 되도록
```

### 간단한 sequential model + 결과창 확인
```
from tensorflow import keras
from tensorflow.keras import layers
model = keras.Sequential([
    layers.Dense(512, activation="relu"),
    layers.Dense(10, activation="softmax")
])
출제 포인트 -> activation 고르기? multi에는 softmax / binomial에는 sigmoid
 
만약 전처리 안해도 되는 형태라면? 
model = models.Sequential([
    layers.Dense(3, activation = "relu"),
    layers.Dense(1, activation = "sigmoid")
])
model.build(input_shape=(None, 2)) -> 여기서 2는 input.shape에서 확인 가능(1000,2)
model.summary()
```

### 컴파일
```
model.compile(optimizer="rmsprop",
              loss="sparse_categorical_crossentropy",
              metrics=["accuracy"])
optimizer, loss, metrics 뭐로 하라고 지정 (적절한 loss 설정하라는 거)
-> sparse_categorical_crossentropy (분류가 여러개의 정수값 + softmax)
-> 	binary_crossentropy   (이진 분류 + sigmoid)
-> categorical_crossentropy (softmax + 분류가 원핫인코딩)
-> mean_squared_error <- 회귀 문제
// 
```

### 모델 돌리기

```
Fit your model using 8 number of epochs with batch size 50. Specify validation data as (test_images, test, labels)
history = model.fit(  # Code here
                    train_images,
                    train_labels,
                    epochs=8,
                    batch_size=50,
                    validation_data=(test_images, test_labels))
+ 평가
## Evaluate your model. Your code here:
model.evaluate( test_images, test_labels)
```

----------------------------------------------------------------------------------------------------

## 시각화
```
## Plot of the ground truth set
import matplotlib.pyplot as plt
plt.scatter(inputs_dev[:, 0], inputs_dev[:, 1], c=targets_dev)
plt.show()

import matplotlib.pyplot as plt
res1 = model.predict(inputs_dev)
decision1 = res1 > .5
plt.scatter(inputs_dev[:, 0], inputs_dev[:, 1], c=decision1)
plt.show()

-> 내 모델로 평가
```

## dense_layer 수동
```
from tensorflow import keras

class SimpleDense(keras.layers.Layer):

    def __init__(self, units, activation=None):
        super().__init__()
        self.units = units
        self.activation = activation

    def build(self, input_shape):
        input_dim = input_shape[-1]
        self.W = self.add_weight(shape=(input_dim, self.units),
                                 initializer="random_normal")
        self.b = self.add_weight(shape=(self.units,),
                                 initializer="zeros")

    def call(self, inputs):
        y = tf.matmul(inputs, self.W) + self.b
        if self.activation is not None:
            y = self.activation(y)
        return y

--
my_dense = SimpleDense(units=32, activation=tf.nn.relu)
input_tensor = tf.ones(shape=(2, 784))
output_tensor = my_dense(input_tensor)
print(output_tensor.shape)
```

-------------------------------------------------------------------

## vectorize
```
- 정수형 아닐 때, 인덱스에 넣어서 찾아줌
def vectorize_sequences(sequences, dimension):
    results = np.zeros((len(sequences), dimension))
    for i, sequence in enumerate(sequences):
        for j in sequence:
            try :
              ### Modify this part
              results[i, word_index[j]] = 1.
            except :
              pass
    return results

x4train = vectorize_sequences(X_train, dimension= len(sorted_words))
x4val = vectorize_sequences(X_val, dimension= len(sorted_words))
x4test = vectorize_sequences(X_test, dimension= len(sorted_words))

정수형일때, 그냥 넣음
import numpy as np
def vectorize_sequences(sequences, dimension=10000):
    results = np.zeros((len(sequences), dimension))
    for i, sequence in enumerate(sequences):
        for j in sequence:
            results[i, j] = 1.
    return results
x_train = vectorize_sequences(train_data)
x_test = vectorize_sequences(test_data)
```

```
원핫인코딩

def to_one_hot(labels, dimension=46):
    results = np.zeros((len(labels), dimension))
    for i, label in enumerate(labels):
        results[i, label] = 1.
    return results
y_train = to_one_hot(train_labels)
y_test = to_one_hot(test_labels)

y_train = to_categorical(train_labels)
y_test = to_categorical(test_labels)
```

